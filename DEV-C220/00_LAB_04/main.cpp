#include <cassert>
#include <queue>
#include <stack>

#include "functions.h"
#include "range.h"
#include "sequence_print.h"
#include "summation.h"

using namespace std::literals;

constexpr int factorial(int n) {
    return (n <= 1) ? 1 : n * factorial(n - 1);
}

int main() {
    // Задание 1. Реализуйте вычисление факториала с помощью constexpr-функции.
    // Подсказки/напоминания:
    //		- constexpr – функция должна состоять из единственной инструкции return <выражение>; (пока!)
    //		- но это выражение может включать вызов другой constexpr – функции, в частности рекурсивный вызов
    //		- если параметр рекурсивной constexpr- функции - это константа, компилятор вычислит результат на этапе компиляции

    // Проверьте тот факт, что компилятор вычисляет значение на этапе компиляции (если в качествепараметра используется константа, известная компилятору на этапе компиляции).
    //  Для проверки достаточно создать встроенный массив с размерностью, вычисляемой посредством constexpr-функции:

    // {
    //     int ar[factorial(3)];
    //     constexpr int n = factorial(5);
    //     std::cout << "factorial(5) = "s << n << std::endl;
    //     // int ar1[n];

    //     const int m = 7;  // OK
    //     // int m = 7;     // ERROR
    //     constexpr int n1 = factorial(m);
    //     int ar1[n1];

    //     int n2 = factorial(m);
    // }

    // Задание 2a. Перевод с помощью пользовательского литерала из двоичного представления строкового в значение,
    // например: строку "100000000" -> в значение 256
    // Проверить результат посредством префикса 0b
    // Чтобы вызов пользовательского литерала выглядел просто и читаемо, например: 100000000_b
    // логично использовать пользовательский литерал с единственным параметром - const char*

    // Так как речь идет о литералах, логично вычислять значения на этапе компиляции
    //  => реализуйте пользовательский литерал посредством constexpr - функций
    // Подсказка/напоминание:
    //		- constexpr – функция должна состоять из единственной инструкции return <выражение>;
    //		- но это выражение может включать вызов другой constexpr – функции,
    //		- которая может быть рекурсивной (если параметр такой функции - это константа,
    //		  компилятор вычислит результат вызова рекурсивной функции на этапе компиляции)
    // {
    //     100000000_b;
    //     111_b;
    //     0_b;
    // }

    // Задание 2b. Перевод в строковое двоичное представление, например: 256 -> "0b100000000"
    // Так как строка может быть любой длины, логичнее и проще возвращать объект std::string
    //=> возвращаемое значение не может быть constexpr!
    // Подсказка: манипулятора std::bin пока нет => преобразование в двоичную строку придется делать вручную
    // Подсказка: количество разрядов в байте определяет константа CHAR_BIT - <cstdint>

    // Должно работать так:
    // std::string sBin = 256_toBinStr;
    {
        // std::string sBin1 = 256_toBinStr;
        // assert(sBin1 == std::string("100000000"s));

        // std::string sBin2 = 7_toBinStr;
        // assert(sBin2 == std::string("111"s));

        // std::string sBin3 = 11_toBinStr;
        // assert(sBin3 == std::string("1011"s));

        // std::cout << "11 = "s
        //           << "0b"s << sBin3 << std::endl;
    }

    // Задание 3. constexpr - объекты
    // Создать класс (шаблон класса?) для хранения и манипулирования диапазоном значений.
    // В классе должны быть:
    //	- переменные для хранения минимального и максимального значений;
    //	- методы для получения каждого из значений;
    //	- метод для проверки - попадает ли указанное значение в диапазон
    //	- метод, который получает любое значение данного типа и формирует результирующее значение:
    //    если принадлежит диапазону, то его и возвращаем;
    //    если меньше минимального значения, то возвращаем минимальное;
    //    если больше максимального значения, то возвращаем максимальное.

    // Проверьте тот факт, что компилятор вычисляет значение на этапе компиляции.
    {
        // constexpr RangeMinMax<int> int_minmax_range(-500, 600);
        // constexpr int x = int_minmax_range.CheckAndGet(1800);
        // // auto x = 600;
        // std::cout << "x = "s << x << std::endl;
        // constexpr auto y = x;
    }

    // Задание 4.
    /*
    Реализуйте шаблон функции для печати любых последовательностей (vector, list, deque, set и встроенного массива), которые могут содержать:
        - как объекты любого типа,
        - так и указатели на объекты любого типа (указатели распечатывать неинтересно => в этом случае следует получать значение по адресу)
    Подсказки: if constexpr
    */
    // {
    //     std::vector<int> v1{1, 2, 3, 4};
    //     PrintCollection(v1);

    //     int x1 = 44;
    //     int x2 = 55;
    //     int x3 = 66;

    //     std::vector<int*> v2{&x1, &x2, &x3};
    //     PrintCollection(v2);
    // }

    // Задание 5.
    /* Реализуйте шаблон функции сложения двух значений.
    Если первое слагаемое является вектором, то все элементы вектора нужно увеличить на значение второго параметра.
    При этом элементы вектора и второй параметр должны быть одного и того же типа.
    Подсказки: if constexpr, is_same
    */
    // {
    //     std::vector<int> v1{1, 2, 3};
    //     int b = 2;
    //     auto _sum = summation(v1, b);
    //     PrintCollection(v1);
    //     std::cout << "_sum = "s << _sum << std::endl;
    // }

    // {
    //     int a = 15;
    //     int b = 30;
    //     auto _sum = summation(a, b);
    //     std::cout << "_sum = "s << _sum << std::endl;
    // }

    // {
    //     // ERROR
    //     std::vector<int> v1{1, 2, 3};
    //     auto _sum = summation(v1, 2.2);
    //     PrintCollection(v1);
    //     std::cout << "_sum = "s << _sum << std::endl;
    // }

    // {
    //     // ERROR
    //     std::vector<double> v1{1.2, 2.2, 3.2};
    //     auto _sum = summation(v1, 2);
    //     PrintCollection(v1);
    //     std::cout << "_sum = "s << _sum << std::endl;
    // }

    // Задание 6.
    /* 	Реализуйте шаблон функции вывода на печать значений элементов любого адаптера (stack, queue, priority_queue)
    Подсказки: if constexpr, is_same
    Предусмотрите вывод значений, если в адаптере хранятся указатели.
    */
    {
        // std::stack<int> st;
        // st.push(10);
        // st.push(20);
        // st.push(30);
        // st.push(40);

        // std::queue<int> q;
        // q.push(111);
        // q.push(222);
        // q.push(333);
        // q.push(444);

        const auto data = {1, 8, 5, 6, 3, 4, 0, 9, 7, 2};
        std::priority_queue<int> q1;  // Max priority queue
        for (int n : data)
            q1.push(n);

        PrintAdapter(q1);
    }

    return 0;
}
