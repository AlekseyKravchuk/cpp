#include <cassert>

#include "functions.h"

using namespace std::literals;

constexpr int factorial(int n) {
    return (n <= 1) ? 1 : n * factorial(n - 1);
}

int main() {
    // Задание 1. Реализуйте вычисление факториала с помощью constexpr-функции.
    // Подсказки/напоминания:
    //		- constexpr – функция должна состоять из единственной инструкции return <выражение>; (пока!)
    //		- но это выражение может включать вызов другой constexpr – функции, в частности рекурсивный вызов
    //		- если параметр рекурсивной constexpr- функции - это константа, компилятор вычислит результат на этапе компиляции

    // Проверьте тот факт, что компилятор вычисляет значение на этапе компиляции (если в качествепараметра используется константа, известная компилятору на этапе компиляции).
    //  Для проверки достаточно создать встроенный массив с размерностью, вычисляемой посредством constexpr-функции:

    // {
    //     int ar[factorial(3)];
    //     constexpr int n = factorial(5);
    //     std::cout << "factorial(5) = "s << n << std::endl;
    //     // int ar1[n];

    //     const int m = 7;  // OK
    //     // int m = 7;     // ERROR
    //     constexpr int n1 = factorial(m);
    //     int ar1[n1];

    //     int n2 = factorial(m);
    // }

    // Задание 2a. Перевод с помощью пользовательского литерала из двоичного представления строкового в значение,
    // например: строку "100000000" -> в значение 256
    // Проверить результат посредством префикса 0b
    // Чтобы вызов пользовательского литерала выглядел просто и читаемо, например: 100000000_b
    // логично использовать пользовательский литерал с единственным параметром - const char*

    // Так как речь идет о литералах, логично вычислять значения на этапе компиляции
    //  => реализуйте пользовательский литерал посредством constexpr - функций
    // Подсказка/напоминание:
    //		- constexpr – функция должна состоять из единственной инструкции return <выражение>;
    //		- но это выражение может включать вызов другой constexpr – функции,
    //		- которая может быть рекурсивной (если параметр такой функции - это константа,
    //		  компилятор вычислит результат вызова рекурсивной функции на этапе компиляции)
    // {
    //     100000000_b;
    //     111_b;
    //     0_b;
    // }

    // Задание 2b. Перевод в строковое двоичное представление, например: 256 -> "0b100000000"
    // Так как строка может быть любой длины, логичнее и проще возвращать объект std::string
    //=> возвращаемое значение не может быть constexpr!
    // Подсказка: манипулятора std::bin пока нет => преобразование в двоичную строку придется делать вручную
    // Подсказка: количество разрядов в байте определяет константа CHAR_BIT - <cstdint>

    // Должно работать так:
    // std::string sBin = 256_toBinStr;
    {
        std::string sBin1 = 256_toBinStr;
        assert(sBin1 == std::string("100000000"s));

        std::string sBin2 = 7_toBinStr;
        assert(sBin2 == std::string("111"s));

        std::string sBin3 = 11_toBinStr;
        assert(sBin3 == std::string("1011"s));

        std::cout << "11 = "s
                  << "0b"s << sBin3 << std::endl;
    }

    // Задание 3. constexpr - объекты
    // Создать класс (шаблон класса?) для хранения и манипулирования диапазоном значений.
    // В классе должны быть:
    //	- переменные для хранения минимального и максимального значений;
    //	- методы для получения каждого из значений;
    //	- метод для проверки - попадает ли указанное значение в диапазон
    //	- метод, который получает любое значение данного типа и формирует результирующее значение:
    //    если принадлежит диапазону, то его и возвращаем;
    //    если меньше минимального значения, то возвращаем минимальное;
    //    если больше максимального значения, то возвращаем максимальное.

    // Проверьте тот факт, что компилятор вычисляет значение на этапе компиляции.
    {
        
    }

    return 0;
}
