#include <iostream>
#include <string>

using namespace std::literals;

class A {
   public:
    void fun() {
        std::cout << "Function \"fun\" in class A."s << std::endl;
    }
};

// Здесь работает "правило замещения имен", то есть в производном классе одноименный метод (сигнатуры методов должны быть ОДИНАКОВЫМИ)
// перекрывает собой область видимости того же самого public-метода в базовом классе
class B : public A {
   public:
    void fun() {
        std::cout << "Function \"fun\" in class B."s << std::endl;
    }
};

int main() {
    B* p1 = new B;
    // при выборе обычного метода (не виртуального) компилятор исходит из типа указателя
    // у нас указатель типа производного класса => компилятор генерирует вызов метода из производного класса
    p1->fun();

    // но при желании можно посредством указателя на производный класс
    // вызвать public-метод базового класса
    p1->A::fun();

    A* p2 = p1;

    // а здесь имеем указатель на базовый класс (поскольку указатель на B приводится компилятором к указателю на А)
    // => компилятор генерирует вызов метода из базового класса (ИСХОДЯ ИЗ ТИПА УКАЗАТЕЛЯ)
    p2->fun();

    return 0;
}
