// захват массива в лямбда-функции

#include <iostream>
#include <string>

#include "my_print.h"

using namespace std::literals;

int main() {
    int ar[] = {1, 2, 3};

    // захватываем ПО ЗНАЧЕНИЮ - компилятор в анонимном функторе создает переменную-член, которая является внедренным массивом
    // и инициализирует её КОПИЕЙ исходного массива (скопирует во внедренный массив функтора элементы из массива-орининала)
    // соответственно, никаких изменений в орининальном массиве не произойдет
    // изменения коснутся только массива, который внедрен в анонимный функтор (т.е. копии оригинального массива)
    // поскольку компилятор формирует "operator()" КОНСТАНТНЫМ,
    // то необходимо указать "mutable" в лямбде, чтобы иметь возможность модифицировать переменные-члены в анонимном функторе
    auto lambda_1 = [ar]() mutable {
        size_t sz = std::size(ar);
        for (size_t i = 0; i < sz; ++i) {
            ar[i] += 100;
        }
    };
    lambda_1();
    PrintCollection(ar, "after applying lambda_1: "s);

    // захватываем ПО ССЫЛКЕ - компилятор в анонимном функторе создает переменную член, которая является адресом начала массива-ОРИГИНАЛА
    // здесь ключевое слово "mutable" уже не нужно, поскольку мы модифицируем не саму переменную член функтора (которая будет ссылочного типа),
    // а ЗНАЧЕНИЕ по этой ССЫЛКЕ
    auto lambda_2 = [&ar]() mutable {
        size_t sz = std::size(ar);
        for (size_t i = 0; i < sz; ++i) {
            ar[i] += 100;
        }
    };
    lambda_2();
    PrintCollection(ar, "after applying lambda_2: "s);

    return 0;
}
