// АНАЛОГИЯ: в базовом и производном классе просто перегруженные методы, которые отличаются сигнатурами
class A {
   public:
    void f(int) {}
    void fA(int) {}
};

class B : public A {
   public:
    using A::f; // можно разрешить область видимости базового класса непосредственно в производном классе

    // в производном классе метод перекрыл область видимости метода из базового класса
    void f(int, int) {}
    void fB(int) {}
};

int main() {
    B b;
    b.f(1, 2);

    // без using в производном классе будет ERROR: no matching function for call to ‘B::f(int)’
    b.f(10);

    // а с помощью разрешения области видимости можно
    // b.A::f(10);

    // в данном случае можем пользоваться методом базового класса посредством объекта производного класса,
    // поскольку перекрытия областей видимости не происходит
    b.fA(55);

    return 0;
}
