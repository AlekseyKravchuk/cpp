#include <chrono>
#include <iostream>
#include <thread>

#include "../../log_duration.h"

void DoWork() {
    {
        LOG_DURATION("DoWork");
        for (size_t i = 0; i < 10; ++i) {
            std::cout << "DoWork thread_ID: " << std::this_thread::get_id()
                      << "; iter #" << i + 1 << std::endl;
            std::this_thread::sleep_for(std::chrono::milliseconds(1000));
        }
    }
}

int main() {
    {
        LOG_DURATION("Total");
        // DoWork();

        // создается новый объект-поток "t1" и новый системный поток (это делает ОС)
        std::thread t1(DoWork);

        // создается новый объект-поток "t1" и новый системный поток (это делает ОС)
        std::thread t2(DoWork);

        // Разрываем связь между объектом-потоком "t1" и системным потоком
        // Сообщаем системному потоку, что он может выполняться самостоятельно, не привязываясь ни к чему.
        // Но в тот момент, когда заканчивает работу основной поток (тот, которым был вызван "t1"), все порожденные им (основным потоком) потоки
        // также будут завершены.
        // Другими словами, текущий поток не будет дожидаться заверешения порожденных потоков, для которых был вызван "detach"
        // Как результат, мы получим UB (Undefined Behaviour) для потока "t1"
        // t1.detach();

        std::cout << "========================================" << std::endl;

        {
            LOG_DURATION("Main for loop");
            for (size_t i = 0; i < 10; ++i) {
                std::cout << "MAIN thread_ID: " << std::this_thread::get_id()
                          << "; iter #" << i + 1 << std::endl;
                std::this_thread::sleep_for(std::chrono::milliseconds(500));
            }
        }

        std::cout << "========================================" << std::endl;

        // Дожидаемся завершения задачи, которая была поставлена в отдельном потоке.
        // !!! При этом текущий поток БЛОКИРУЕТСЯ !!! (соответственно, вся последующая логика не будет выполнена до завершения "t1")
        t1.join(); // здесь дожидаемся завершения потока "t1"

        t2.join(); // здесь дожидаемся завершения потока "t2"
    }

    return 0;
}
