Основная идея подхода
=====================
Прежде чем делать программу многопоточной, нужно выжать максимум из возможностей алгоритмов исходя из особенностей входных данных (Data-Driven Approach).

Все алгоритмы, основанные на сравнениях, в общем случае решают задачу сортировки не лучше чем O(N*log(N)),
в том числе и std::sort, а это достаточно медленно для больших объемов данных (> 1M). По этой причине не стал
заниматься реализацией приведенных в ТЗ общеизвестных алгоритмов сортировки.

O(N*log(N)) можно исправить за счет отказа от методов, основанных на сравнении элементов.

Например, для натуральных чисел, когда разница между минимальным и максимальным числами из диапазона небольшая,
можно огранизовать более эффектвные способы сортировки, работающие за линейное время O(N).

Решил использовать оптимизацию за счет "сортировки подсчетом" (counting sort).
Для сильно перемешанных или случайных наборов данных можно было бы поиграться с RadixSort (не рассматривал).

Запуск исполняемого файла
=====================
- без параметров: программа отработает с предустановленным значением sample_size = 1'000'000;
- в качестве параметра можно указать размер выборки.

Анализ полученных результатов
=====================
Если собирать проект без оптимизаций (-O0), то при sample_size == 5'000'000 получаются следующие результаты (на моем ПК):
- CountingSort:                      104 milliseconds
- CountingSort_MultiThread:          67 milliseconds
- CountingSort_MultiThread_Merge:    489 milliseconds
- std::sort:                         1198 milliseconds

Таким образом, используя алгоритмическую оптимизацию и многопоточность, получаем хороший прирост производительности.
Вместо 1248 ms, которые нам дает нам std::sort, мы укладываемся в ~70 ms. Таким образом ускорили сортировку ~ в 15-17 раз.

ПРИМЕЧАНИЕ: хотелось бы увеличить производительность в количество раз, соответствующее количесту ядер CPU, однако
std::async не отличается определенностью, т.к. всё отдается на откуп планировщику ОС.
Кроме того, порождение потока ДАЛЕКО не бесплатная операция.

Дальнейшее увеличение производительности
=====================
В качестве дальнейшего увеличения производительности целесообразно использовать:
 - низкоуровневые средства, например, Linux'овский epoll (Event Poll);
 - корутины (с ними я ещё не разбирался) - для сокращения издержек на создание потоков;
 - Radix Sort.