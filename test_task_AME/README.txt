Основная идея подхода: прежде чем делать программу многопоточной, нужно выжать максимум из возможностей алгоритмов
исходя из особенностей входных данных (Data-Driven Approach).

Сортировка ОБЫЧНО работает за O(Nlog(N)), в том числе и std::sort, и это достаточно медленно для больших объемов данных.
Для натуральных чисел, когда разница между минимальными и максимальным числамиз в диапазоне небольшая,
можно огранизовать более эффектвные способы сортировки, работающие за линейное время O(N).

Самая тривиальная сортировка подобного рода - это "сортировка подсчетом" (counting sort).
(вариант с RadixSort не рассматривал в силу ограниченности по времени).

Если собирать проект без оптимизаций компилятора (-O0), то получаются следующие результаты (на моем ПК):
CountingSort: 219 milliseconds
CountingSort_MultiThread: 173 milliseconds
CountingSort_MultiThread_Merge: 1095 milliseconds
std::sort: 1737 milliseconds

С оптимизацией (-O3):
CountingSort: 19 milliseconds
CountingSort_MultiThread: 17 milliseconds
CountingSort_MultiThread_Merge: 109 milliseconds
std::sort: 78 milliseconds
В этом случае получаем увеличение производительности в 4.5 раза (CountingSort_MultiThread vs std::sort).

Таким образом, используя алгоритмическую оптимизацию и многопоточность, получаем хороший прирост производительности.
Функция CountingSort_MultiThread работает ~ в 10 раз быстрее

ПРИМЕЧАНИЕ: хотелось бы увеличить производительность в количество раз, соответствующее количесту ядер CPU, однако
std::async не отличается определенностью, т.к. всё отдается на откуп планировщику ОС.
Кроме того, порождение потока - далеко не бесплатная операция.

То есть в качестве дальнейшего увеличения производительности целесообразно использовать:
 - низкоуровневые средства, например, Linux'овский epoll (Event Poll);
 - корутины (с ними я ещё не разбирался);